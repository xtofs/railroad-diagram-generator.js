<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{title}}</title>
    <link rel="stylesheet" href="railroad-diagram.css">
</head>
<body>
    <h1>{{title}}</h1>
    
{{#each rules}}
    <div class="syntax-rule" id="{{sanitizeId name}}">
        <h2>{{name}}</h2>
        <p><code>{{name}} := {{original}}</code></p>
        <div class="diagram-container" data-debug-ast="{{debugString}}">
            {{{svg}}}
        </div>
    </div>
{{/each}}

    <footer class="generator-footer">
        <p>Generated from ABNF grammar using abnf-to-railroad tool</p>
    </footer>

    <script>
        // Add grid pattern to all SVG elements
        function addGridToSVGs() {
            const svgs = document.querySelectorAll('svg');
            const gridSize = 16; // Match the grid size from the renderer
            
            svgs.forEach((svg, svgIndex) => {
                const patternId = `grid-pattern-${svgIndex}`; // Unique ID per SVG
                
                // Create defs element if it doesn't exist, append at end
                let defs = svg.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    svg.appendChild(defs); // Add at end instead of beginning
                }
                
                // Create pattern element in each SVG's defs
                const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
                pattern.setAttribute('id', patternId);
                pattern.setAttribute('patternUnits', 'userSpaceOnUse');
                pattern.setAttribute('width', gridSize);
                pattern.setAttribute('height', gridSize);
                
                // Add a light background to the pattern to make it more visible
                const patternBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                patternBg.setAttribute('width', gridSize);
                patternBg.setAttribute('height', gridSize);
                patternBg.setAttribute('fill', 'rgba(255, 182, 193, 0.05)'); // Very subtle pink background
                pattern.appendChild(patternBg);
                
                // Create subtle grid pattern with short lines at intersections
                function createGridLine(x1, y1, x2, y2) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('stroke', 'hotpink');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('opacity', '0.6');
                    pattern.appendChild(line);
                }

                // Create short horizontal lines (left and right edges)
                createGridLine(0, 0, 4, 0);
                createGridLine(gridSize-4, 0, gridSize, 0);
                
                // Create short vertical lines (top and bottom edges)
                createGridLine(0, 0, 0, 4);
                createGridLine(0, gridSize-4, 0, gridSize);
             
                defs.appendChild(pattern);
                
                // Get SVG dimensions
                const svgRect = svg.getBoundingClientRect();
                const svgWidth = svg.getAttribute('width') || svgRect.width;
                const svgHeight = svg.getAttribute('height') || svgRect.height;
                
                // Create background rectangle that covers the entire SVG
                const background = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                background.setAttribute('x', '0');
                background.setAttribute('y', '0');
                background.setAttribute('width', svgWidth);
                background.setAttribute('height', svgHeight);
                background.setAttribute('fill', `url(#${patternId})`);
                background.setAttribute('class', 'grid-background');
                
                // Insert background right after defs but before any other content
                const firstChild = svg.children[0];
                if (firstChild && firstChild !== defs) {
                    svg.insertBefore(background, firstChild);
                } else {
                    svg.appendChild(background);
                }
            });
        }
        
        // Add grid when DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', addGridToSVGs);
        } else {
            addGridToSVGs();
        }
        
        // Add bounding boxes to all group elements
        function addBoundingBoxes() {
            const svgs = document.querySelectorAll('svg');
            
            svgs.forEach((svg) => {
                const groups = svg.querySelectorAll('g[transform]');
                
                groups.forEach((group) => {
                    // Get the bounding box of the group's content
                    const bbox = group.getBBox();
                    
                    // Create a bounding box rectangle aligned with grid
                    const boundingBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    boundingBox.setAttribute('x', bbox.x);
                    boundingBox.setAttribute('y', bbox.y);
                    boundingBox.setAttribute('width', bbox.width);
                    boundingBox.setAttribute('height', bbox.height);
                    boundingBox.setAttribute('fill', 'none');
                    boundingBox.setAttribute('stroke', 'hotpink');
                    boundingBox.setAttribute('stroke-width', '0.5');
                    boundingBox.setAttribute('opacity', '0.9');
                    boundingBox.setAttribute('class', 'bounding-box');
                    
                    // Insert at the beginning of the group so it's behind content
                    group.insertBefore(boundingBox, group.firstChild);
                });
            });
        }
        
        // Add bounding boxes when DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', addBoundingBoxes);
        } else {
            addBoundingBoxes();
        }
        
        // Add separate toggle functionality for grid and bounding boxes
        document.addEventListener('keydown', function(e) {
            // Toggle grid with Ctrl+G
            if (e.key === 'g' && e.ctrlKey) {
                e.preventDefault();
                console.log('Ctrl+G pressed - toggling grid view');
                
                const gridElements = document.querySelectorAll('.grid-background');
                console.log(`Found ${gridElements.length} grid elements`);
                
                gridElements.forEach((grid, index) => {
                    const wasVisible = grid.classList.contains('visible');
                    if (wasVisible) {
                        grid.classList.remove('visible');
                    } else {
                        grid.classList.add('visible');
                    }
                    console.log(`Grid ${index}: ${wasVisible ? 'visible' : 'hidden'} -> ${!wasVisible ? 'visible' : 'hidden'}`);
                });
            }
            
            // Toggle bounding boxes with Ctrl+B
            if (e.key === 'b' && e.ctrlKey) {
                e.preventDefault();
                console.log('Ctrl+B pressed - toggling bounding box view');
                
                const boundingBoxElements = document.querySelectorAll('.bounding-box');
                console.log(`Found ${boundingBoxElements.length} bounding boxes`);
                
                boundingBoxElements.forEach((bbox, index) => {
                    const wasVisible = bbox.classList.contains('visible');
                    if (wasVisible) {
                        bbox.classList.remove('visible');
                    } else {
                        bbox.classList.add('visible');
                    }
                    console.log(`BBox ${index}: ${wasVisible ? 'visible' : 'hidden'} -> ${!wasVisible ? 'visible' : 'hidden'}`);
                });
            }
        });
        
        // Add click navigation for nonterminal textboxes
        function addNonterminalNavigation() {
            const nonterminalTextElements = document.querySelectorAll('.textbox-text.nonterminal');
            
            nonterminalTextElements.forEach((textElement) => {
                textElement.style.cursor = 'pointer';
                
                textElement.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const ruleName = textElement.textContent.trim();
                    const targetElement = document.getElementById(ruleName);
                    
                    if (targetElement) {
                        console.log(`Navigating to rule: ${ruleName}`);
                        
                        // Update the URL hash
                        history.pushState(null, null, `#${ruleName}`);
                        
                        targetElement.scrollIntoView({ 
                            block: 'start' 
                        });
                    } else {
                        console.log(`Rule not found: ${ruleName}`);
                        alert(`Rule "${ruleName}" not found in this document.`);
                    }
                });
            });
        }
        
        // Add nonterminal navigation when DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', addNonterminalNavigation);
        } else {
            addNonterminalNavigation();
        }
    </script>
</body>
</html>