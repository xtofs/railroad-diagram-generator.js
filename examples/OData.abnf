;     OData Version 4.01
;     OASIS Standard
;     23 April 2020
;    
; Copyright (c) OASIS Open 2020. All Rights Reserved.
;     Source:
; https://docs.oasis-open.org/odata/odata/v4.01/os/abnf/
;     Latest version of narrative
; specification:
; https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html
;     TC IPR Statement:
; https://www.oasis-open.org/committees/odata/ipr.php
;
;------------------------------------------------------------------------------
;
; OData ABNF Construction Rules Version 4.01 and 4.0
;------------------------------------------------------------------------------
; 05 November 2019
;------------------------------------------------------------------------------
;
;
; Technical Committee:
;   OASIS Open Data Protocol (OData) TC
;   https://www.oasis-open.org/committees/odata
;
; Chairs:
;   - Ralf Handl (ralf.handl@sap.com), SAP SE
;   - Michael Pizzo (mikep@microsoft.com), Microsoft
;
; Editors:
;   - Ralf Handl (ralf.handl@sap.com), SAP SE
;   - Michael Pizzo (mikep@microsoft.com), Microsoft
;   - Martin Zurmuehl (martin.zurmuehl@sap.com), SAP SE

; Note: This is a subset of the full OData ABNF grammar for testing purposes
; The full grammar is available at:
; https://docs.oasis-open.org/odata/odata/v4.01/os/abnf/odata-abnf-construction-rules.txt

; Test a subset of OData URI components
odataUri = serviceRoot [ odataRelativeUri ]  

serviceRoot = ( "https" / "http" )                    ; Note: case-insensitive 
              "://"
              host [ ":" port ]
              "/" *( segment-nz "/" )

; Note: dollar-prefixed path segments are case-sensitive!
odataRelativeUri = "$batch"  [ "?" batchOptions ]
                 / "$entity" "?" entityOptions  
                 / "$entity" "/" optionallyQualifiedEntityTypeName "?" entityCastOptions  
                 / "$metadata" [ "?" metadataOptions ] [ context ]
                 / resourcePath [ "?" queryOptions ]

;------------------------------------------------------------------------------
; 1. Resource Path
;------------------------------------------------------------------------------

resourcePath = entitySetName                 [ collectionNavigation ] 
             / singletonEntity               [ singleNavigation ]
             / actionImportCall 
             / entityColFunctionImportCall   [ collectionNavigation ] 
             / entityFunctionImportCall      [ singleNavigation ] 
             / complexColFunctionImportCall  [ complexColPath ] 
             / complexFunctionImportCall     [ complexPath ] 
             / primitiveColFunctionImportCall [ primitiveColPath ] 
             / primitiveFunctionImportCall   [ primitivePath ] 
             / functionImportCallNoParens    [ querySegment ]
             / crossjoin                     [ querySegment ]
             / "$all"                        [ "/" optionallyQualifiedEntityTypeName ]

collectionNavigation = [ "/" optionallyQualifiedEntityTypeName ] [ collectionNavPath ]
collectionNavPath    = keyPredicate [ singleNavigation ]
                     / filterInPath [ collectionNavigation ]
                     / each [ boundOperation ]
                     / boundOperation
                     / count
                     / ref
                     / querySegment

keyPredicate     = simpleKey / compoundKey / keyPathSegments
simpleKey        = OPEN ( parameterAlias / keyPropertyValue ) CLOSE
compoundKey      = OPEN keyValuePair *( COMMA keyValuePair ) CLOSE
keyValuePair     = ( primitiveKeyProperty / keyPropertyAlias  ) EQ ( parameterAlias / keyPropertyValue )
keyPropertyValue = primitiveLiteral
keyPropertyAlias = odataIdentifier
keyPathSegments  = 1*( "/" keyPathLiteral )
keyPathLiteral   = *pchar

singleNavigation = [ "/" optionallyQualifiedEntityTypeName ] 
                   [ "/" ( propertyPath / boundOperation / ref / value / querySegment ) ]

filterInPath = "/$filter" OPEN boolCommonExpr CLOSE

each  = "/$each"
count = "/$count"
ref   = "/$ref"
value = "/$value"

querySegment = "/$query"

;------------------------------------------------------------------------------
; 2. Query Options
;------------------------------------------------------------------------------

queryOptions = queryOption *( "&" queryOption )        
queryOption  = systemQueryOption  
             / aliasAndValue 
             / nameAndValue
             / customQueryOption  

systemQueryOption = compute
                  / deltatoken
                  / expand 
                  / filter 
                  / format 
                  / id
                  / inlinecount 
                  / orderby 
                  / schemaversion
                  / search
                  / select 
                  / skip 
                  / skiptoken
                  / top 
                  / index

compute          = ( "$compute" / "compute" ) EQ computeItem *( COMMA computeItem )
computeItem      = commonExpr RWS "as" RWS computedProperty
computedProperty = odataIdentifier         

expand           = ( "$expand" / "expand" ) EQ expandItem *( COMMA expandItem )
expandItem       = "$value"
                 / expandPath
                 / optionallyQualifiedEntityTypeName "/" expandPath

filter = ( "$filter" / "filter" ) EQ boolCommonExpr

orderby     = ( "$orderby" / "orderby" ) EQ orderbyItem *( COMMA orderbyItem )
orderbyItem = commonExpr [ RWS ( "asc" / "desc" ) ]

skip = ( "$skip" / "skip" ) EQ 1*DIGIT
top  = ( "$top"  / "top"  ) EQ 1*DIGIT

format = ( "$format" / "format" ) EQ
         ( "atom"
         / "json" 
         / "xml"
         / 1*pchar "/" 1*pchar ; service specific format
         )                     

inlinecount = ( "$count" / "count" ) EQ booleanValue

search = ( "$search" / "search" ) EQ BWS ( searchExpr / searchExpr-incomplete )

searchExpr = ( searchParenExpr
             / searchNegateExpr
             / searchPhrase
             / searchWord 
             ) [ searchOrExpr
               / searchAndExpr
               ]

select = ( "$select" / "select" ) EQ selectItem *( COMMA selectItem )
selectItem = STAR
           / allOperationsInSchema 
           / selectProperty

customQueryOption = customName [ EQ customValue ]
customName        = qchar-no-AMP-EQ-AT-DOLLAR *( qchar-no-AMP-EQ ) 
customValue       = *( qchar-no-AMP )

;------------------------------------------------------------------------------
; 4. Expressions
;------------------------------------------------------------------------------

; Note: a boolCommonExpr is also a commonExpr, e.g. sort by Boolean 
commonExpr = ( primitiveLiteral
             / arrayOrObject
             / rootExpr
             / firstMemberExpr
             / functionExpr
             / negateExpr 
             / methodCallExpr 
             / parenExpr 
             / castExpr 
             / isofExpr
             / notExpr
             ) 
             [ addExpr 
             / subExpr 
             / mulExpr 
             / divExpr
             / divbyExpr 
             / modExpr
             ]  
             [ eqExpr 
             / neExpr 
             / ltExpr 
             / leExpr  
             / gtExpr 
             / geExpr 
             / hasExpr 
             / inExpr 
             ]
             [ andExpr 
             / orExpr 
             ] 

boolCommonExpr = commonExpr ; resulting in a Boolean

parenExpr = OPEN BWS commonExpr BWS CLOSE

andExpr = RWS "and" RWS boolCommonExpr
orExpr  = RWS "or"  RWS boolCommonExpr

eqExpr = RWS "eq" RWS commonExpr    
neExpr = RWS "ne" RWS commonExpr
ltExpr = RWS "lt" RWS commonExpr
leExpr = RWS "le" RWS commonExpr
gtExpr = RWS "gt" RWS commonExpr
geExpr = RWS "ge" RWS commonExpr
inExpr = RWS "in" RWS ( listExpr / commonExpr )

hasExpr = RWS "has" RWS enum

addExpr   = RWS "add"   RWS commonExpr
subExpr   = RWS "sub"   RWS commonExpr
mulExpr   = RWS "mul"   RWS commonExpr
divExpr   = RWS "div"   RWS commonExpr
divbyExpr = RWS "divby" RWS commonExpr
modExpr   = RWS "mod"   RWS commonExpr

negateExpr = "-" BWS commonExpr
notExpr = "not" RWS boolCommonExpr

;------------------------------------------------------------------------------
; 6. Names and identifiers
;------------------------------------------------------------------------------

; an alias is just a single-part namespace
namespace     = namespacePart *( "." namespacePart )
namespacePart = odataIdentifier

entitySetName       = odataIdentifier
singletonEntity     = odataIdentifier          
entityTypeName      = odataIdentifier
complexTypeName     = odataIdentifier

; Note: this pattern is overly restrictive, the normative definition is type TSimpleIdentifier in OData EDM XML Schema
odataIdentifier             = identifierLeadingCharacter *127identifierCharacter
identifierLeadingCharacter  = ALPHA / "_"         ; plus Unicode characters from the categories L or Nl
identifierCharacter         = ALPHA / "_" / DIGIT ; plus Unicode characters from the categories L, Nl, Nd, Mn, Mc, Pc, or Cf

primitiveTypeName = "Edm." ( "Binary"
                           / "Boolean"
                           / "Byte"
                           / "Date" 
                           / "DateTimeOffset"
                           / "Decimal"
                           / "Double"
                           / "Duration" 
                           / "Guid" 
                           / "Int16"
                           / "Int32"
                           / "Int64"
                           / "SByte"
                           / "Single"
                           / "Stream"
                           / "String"
                           / "TimeOfDay"
                           )

optionallyQualifiedEntityTypeName  = [ namespace "." ] entityTypeName
optionallyQualifiedComplexTypeName = [ namespace "." ] complexTypeName

primitiveProperty       = primitiveKeyProperty / primitiveNonKeyProperty
primitiveKeyProperty    = odataIdentifier
primitiveNonKeyProperty = odataIdentifier

;------------------------------------------------------------------------------
; 7. Literal Data Values
;------------------------------------------------------------------------------

; in URLs
primitiveLiteral = nullValue                  ; plain values up to int64Value
                 / booleanValue 
                 / guidValue 
                 / dateTimeOffsetValueInUrl 
                 / dateValue
                 / timeOfDayValueInUrl
                 / decimalValue 
                 / doubleValue 
                 / singleValue 
                 / sbyteValue 
                 / byteValue
                 / int16Value 
                 / int32Value 
                 / int64Value 
                 / string                     ; single-quoted
                 / duration
                 / enum
                 / binary                     ; all others are quoted and prefixed 

nullValue = "null" 

; base64url encoding according to http://tools.ietf.org/html/rfc4648#section-5                               
binary      = "binary" SQUOTE binaryValue SQUOTE
binaryValue = *(4base64char) [ base64b16  / base64b8 ]
base64char  = ALPHA / DIGIT / "-" / "_"

booleanValue = "true" / "false"

decimalValue = [ SIGN ] 1*DIGIT [ "." 1*DIGIT ] [ "e" [ SIGN ] 1*DIGIT ] / nanInfinity
doubleValue  = decimalValue ; IEEE 754 binary64 floating-point number (15-17 decimal digits)
singleValue  = decimalValue ; IEEE 754 binary32 floating-point number (6-9 decimal digits)
nanInfinity  = "NaN" / "-INF" / "INF"

guidValue = 8HEXDIG "-" 4HEXDIG "-" 4HEXDIG "-" 4HEXDIG "-" 12HEXDIG 

byteValue  = 1*3DIGIT           ; numbers in the range from 0 to 255
sbyteValue = [ SIGN ] 1*3DIGIT  ; numbers in the range from -128 to 127
int16Value = [ SIGN ] 1*5DIGIT  ; numbers in the range from -32768 to 32767        
int32Value = [ SIGN ] 1*10DIGIT ; numbers in the range from -2147483648 to 2147483647
int64Value = [ SIGN ] 1*19DIGIT ; numbers in the range from -9223372036854775808 to 9223372036854775807

string           = SQUOTE *( SQUOTE-in-string / pchar-no-SQUOTE ) SQUOTE
SQUOTE-in-string = SQUOTE SQUOTE ; two consecutive single quotes represent one within a string literal

dateValue = year "-" month "-" day

dateTimeOffsetValueInUrl = year "-" month "-" day "T" timeOfDayValueInUrl ( "Z" / SIGN hour COLON minute )

duration      = [ "duration" ] SQUOTE durationValue SQUOTE
durationValue = [ SIGN ] "P" [ 1*DIGIT "D" ] [ "T" [ 1*DIGIT "H" ] [ 1*DIGIT "M" ] [ 1*DIGIT [ "." 1*DIGIT ] "S" ] ]

timeOfDayValueInUrl = hour COLON minute [ COLON second [ "." fractionalSeconds ] ]

oneToNine       = "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"
zeroToFiftyNine = ( "0" / "1" / "2" / "3" / "4" / "5" ) DIGIT
year  = [ "-" ] ( "0" 3DIGIT / oneToNine 3*DIGIT )
month = "0" oneToNine / "1" ( "0" / "1" / "2" )
day   = "0" oneToNine / ( "1" / "2" ) DIGIT / "3" ( "0" / "1" )
hour   = ( "0" / "1" ) DIGIT / "2" ( "0" / "1" / "2" / "3" ) 
minute = zeroToFiftyNine
second = zeroToFiftyNine / "60" ; for leap seconds
fractionalSeconds = 1*12DIGIT

enum            = [ qualifiedEnumTypeName ] SQUOTE enumValue SQUOTE
enumValue       = singleEnumValue *( COMMA singleEnumValue )
singleEnumValue = enumerationMember / enumMemberValue
enumMemberValue = int64Value

;------------------------------------------------------------------------------
; 9. Punctuation
;------------------------------------------------------------------------------

RWS = 1*( SP / HTAB / "%20" / "%09" )  ; "required" whitespace 
BWS =  *( SP / HTAB / "%20" / "%09" )  ; "bad" whitespace

AT     = "@" / "%40"
COLON  = ":" / "%3A"
COMMA  = "," / "%2C"
EQ     = "="
HASH   = "%23" ; the # character is not allowed in the query part
SIGN   = "+" / "%2B" / "-"
SEMI   = ";" / "%3B"
STAR   = "*" / "%2A"
SQUOTE = "'" / "%27"

OPEN  = "(" / "%28"
CLOSE = ")" / "%29"

;------------------------------------------------------------------------------
; A. URI syntax [RFC3986] - subset
;------------------------------------------------------------------------------

scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
host          = IP-literal / IPv4address / reg-name
port          = *DIGIT
reg-name      = *( unreserved / pct-encoded / sub-delims )
segment-nz    = 1*pchar
pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
pct-encoded   = "%" HEXDIG HEXDIG
unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
sub-delims    = "$" / "&" / "'" / "=" / other-delims
other-delims  = "!" / "(" / ")" / "*" / "+" / "," / ";"

pchar-no-SQUOTE       = unreserved / pct-encoded-no-SQUOTE / other-delims / "$" / "&" / "=" / ":" / "@"
pct-encoded-no-SQUOTE = "%" ( "0" / "1" /   "3" / "4" / "5" / "6" / "8" / "9" / A-to-F ) HEXDIG 
                      / "%" "2" ( "0" / "1" / "2" / "3" / "4" / "5" / "6" /   "8" / "9" / A-to-F )

qchar-no-AMP              = unreserved / pct-encoded / other-delims / ":" / "@" / "/" / "?" / "$" / "'" / "="
qchar-no-AMP-EQ           = unreserved / pct-encoded / other-delims / ":" / "@" / "/" / "?" / "$" / "'"
qchar-no-AMP-EQ-AT-DOLLAR = unreserved / pct-encoded / other-delims / ":" /       "/" / "?" /       "'"

;------------------------------------------------------------------------------
; C. ABNF core definitions [RFC5234]
;------------------------------------------------------------------------------

ALPHA  = %x41-5A / %x61-7A 
DIGIT  = %x30-39 
HEXDIG = DIGIT / A-to-F
A-to-F = "A" / "B" / "C" / "D" / "E" / "F" 
DQUOTE = %x22
SP     = %x20 
HTAB   = %x09 
VCHAR  = %x21-7E 

; Placeholder rules for missing definitions
host = reg-name
IP-literal = "[" IPv6address "]"
IPv4address = 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT "." 1*3DIGIT
IPv6address = 1*4HEXDIG *7(":" 1*4HEXDIG)

; Additional placeholders needed
batchOptions = queryOptions
entityOptions = queryOptions  
entityCastOptions = queryOptions
metadataOptions = queryOptions
context = "#" 1*ALPHA

actionImportCall = odataIdentifier
entityColFunctionImportCall = odataIdentifier OPEN CLOSE
entityFunctionImportCall = odataIdentifier OPEN CLOSE
complexColFunctionImportCall = odataIdentifier OPEN CLOSE
complexFunctionImportCall = odataIdentifier OPEN CLOSE
primitiveColFunctionImportCall = odataIdentifier OPEN CLOSE
primitiveFunctionImportCall = odataIdentifier OPEN CLOSE
functionImportCallNoParens = odataIdentifier

crossjoin = '$crossjoin' OPEN entitySetName *( COMMA entitySetName ) CLOSE

complexColPath = count
complexPath = value
primitiveColPath = count
primitivePath = value

boundOperation = "/" odataIdentifier

propertyPath = odataIdentifier

parameterAlias = AT odataIdentifier
aliasAndValue = parameterAlias EQ parameterValue
nameAndValue = odataIdentifier EQ parameterValue
parameterValue = primitiveLiteral

deltatoken = "$deltatoken" EQ 1*( qchar-no-AMP )
skiptoken = "$skiptoken" EQ 1*( qchar-no-AMP )
index = ( "$index" / "index" ) EQ 1*DIGIT
schemaversion = ( "$schemaversion" / "schemaversion" ) EQ ( STAR / 1*unreserved )

expandPath = odataIdentifier
selectProperty = odataIdentifier
allOperationsInSchema = namespace "." STAR

searchParenExpr = OPEN BWS searchExpr BWS CLOSE
searchNegateExpr = 'NOT' RWS searchExpr
searchOrExpr = RWS 'OR' RWS searchExpr
searchAndExpr = RWS [ 'AND' RWS ] searchExpr
searchPhrase = DQUOTE 1*( VCHAR / SP ) DQUOTE
searchWord = 1*( ALPHA / DIGIT )
searchExpr-incomplete = SQUOTE *( ALPHA / DIGIT / SP ) SQUOTE

arrayOrObject = array / object
array = "[" [ primitiveLiteral *( COMMA primitiveLiteral ) ] "]"
object = "{" [ member *( COMMA member ) ] "}"
member = string ":" primitiveLiteral

rootExpr = '$root/' entitySetName
firstMemberExpr = odataIdentifier
functionExpr = odataIdentifier OPEN CLOSE
methodCallExpr = odataIdentifier OPEN commonExpr CLOSE
castExpr = "cast" OPEN commonExpr COMMA primitiveTypeName CLOSE
isofExpr = "isof" OPEN commonExpr COMMA primitiveTypeName CLOSE

listExpr = OPEN primitiveLiteral *( COMMA primitiveLiteral ) CLOSE

qualifiedEnumTypeName = namespace "." odataIdentifier
enumerationMember = odataIdentifier

base64b16 = 2base64char ( 'A' / 'E' / 'I' / 'M' / 'Q' / 'U' / 'Y' / 'c' / 'g' / 'k' / 'o' / 's' / 'w' / '0' / '4' / '8' ) [ "=" ]
base64b8 = base64char ( 'A' / 'Q' / 'g' / 'w' ) [ "==" ]
